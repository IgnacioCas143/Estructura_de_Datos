// Código para Carro Evita Obstáculos usando Sensor Ultrasónico

// --- Pines de Motores ---
const int motorIzqA = 5;  // Motor Izquierdo A
const int motorIzqB = 6;  // Motor Izquierdo B
const int motorDerA = 10; // Motor Derecho A (Ajustado para evitar conflictos comunes)
const int motorDerB = 11; // Motor Derecho B (Ajustado para evitar conflictos comunes)

// --- Pines Sensor Ultrasónico ---
const int trigPin = 12; // Pin Trig (Ajustado para evitar conflictos comunes)
const int echoPin = 13; // Pin Echo (Ajustado para evitar conflictos comunes)

// --- Variables para medición de distancia ---
long duracionUltrasonico;
int distanciaObstaculo;
bool giroDerechaObstaculo = true; // Dirección de giro para evitar obstáculo

// --- Constantes Configurables ---
const int DISTANCIA_MINIMA = 20;  // Distancia mínima en cm para evitar obstáculo
const int VELOCIDAD_AVANCE = 200; // Velocidad de avance normal (0-255)
const int VELOCIDAD_GIRO = 180;   // Velocidad durante giros (0-255)
const int TIEMPO_GIRO_OBSTACULO = 500; // Tiempo de giro para evitar obstáculo (ms)
const int TIEMPO_RETROCESO = 300; // Tiempo de retroceso (ms)

// --- Constantes de Inversión de Motores ---
const bool INVERTIR_MOTOR_IZQ = false; // Cambiar a true si el motor izquierdo gira al revés
const bool INVERTIR_MOTOR_DER = false; // Cambiar a true si el motor derecho gira al revés

void setup() {
  // Iniciar comunicación serial
  Serial.begin(9600);
  Serial.println("Iniciando Carro Evita Obstáculos...");

  // Configurar pines de motores como SALIDA
  pinMode(motorIzqA, OUTPUT);
  pinMode(motorIzqB, OUTPUT);
  pinMode(motorDerA, OUTPUT);
  pinMode(motorDerB, OUTPUT);

  // Configurar pines sensor ultrasónico
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // Detener motores al inicio
  detener();
  Serial.println("Motores detenidos.");
  delay(1000); // Pausa inicial

  Serial.println("Sistema listo.");
}

void loop() {
  // 1. Medir distancia del obstáculo
  medirDistancia();
  Serial.print("Distancia: ");
  Serial.print(distanciaObstaculo);
  Serial.println(" cm");

  // 2. Lógica de Evasión de Obstáculos
  if (distanciaObstaculo < DISTANCIA_MINIMA && distanciaObstaculo > 0) { // Ignorar lecturas 0 o inválidas
    Serial.println("¡Obstáculo Detectado!");
    detener();
    delay(200);
    // Retroceder
    Serial.println("Retrocediendo...");
    retroceder(VELOCIDAD_AVANCE); // Retroceder a velocidad normal
    delay(TIEMPO_RETROCESO);
    detener();
    delay(200);
    // Girar para evitar
    if (giroDerechaObstaculo) {
      Serial.println("Girando a la Derecha");
      girarDerecha(VELOCIDAD_GIRO);
    } else {
      Serial.println("Girando a la Izquierda");
      girarIzquierda(VELOCIDAD_GIRO);
    }
    delay(TIEMPO_GIRO_OBSTACULO);
    detener();
    delay(200);
    // Alternar dirección de giro para la próxima vez
    giroDerechaObstaculo = !giroDerechaObstaculo;
  }
  // 3. Si no hay obstáculo, avanzar
  else {
    Serial.println("Avanzando");
    avanzar(VELOCIDAD_AVANCE);
  }

  delay(50); // Pequeña pausa en el bucle
}

// --- Funciones de Control de Motores (con inversión y analogWrite) ---

// Función genérica para controlar un par de pines de motor con inversión y velocidad
void controlMotor(int pinA, int pinB, int dirA, int dirB, int velocidad, bool invertir) {
  int nivelA = (dirA == HIGH) ? velocidad : LOW;
  int nivelB = (dirB == HIGH) ? velocidad : LOW;

  if (invertir) {
    // Invierte los pines si es necesario
    analogWrite(pinA, nivelB);
    analogWrite(pinB, nivelA);
  } else {
    analogWrite(pinA, nivelA);
    analogWrite(pinB, nivelB);
  }
}

void avanzar(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, HIGH, LOW, velocidad, INVERTIR_MOTOR_IZQ);
  controlMotor(motorDerA, motorDerB, HIGH, LOW, velocidad, INVERTIR_MOTOR_DER);
}

void retroceder(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, LOW, HIGH, velocidad, INVERTIR_MOTOR_IZQ);
  controlMotor(motorDerA, motorDerB, LOW, HIGH, velocidad, INVERTIR_MOTOR_DER);
}

void girarDerecha(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, HIGH, LOW, velocidad, INVERTIR_MOTOR_IZQ); // Izquierda adelante
  controlMotor(motorDerA, motorDerB, LOW, HIGH, velocidad, INVERTIR_MOTOR_DER); // Derecha atrás
}

void girarIzquierda(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, LOW, HIGH, velocidad, INVERTIR_MOTOR_IZQ); // Izquierda atrás
  controlMotor(motorDerA, motorDerB, HIGH, LOW, velocidad, INVERTIR_MOTOR_DER); // Derecha adelante
}

void detener() {
  // Poner ambos pines en LOW detiene la mayoría de los drivers
  analogWrite(motorIzqA, 0);
  analogWrite(motorIzqB, 0);
  analogWrite(motorDerA, 0);
  analogWrite(motorDerB, 0);
}

// --- Funciones del Sensor Ultrasónico ---
void medirDistancia() {
  // Limpiar el trigger
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  // Enviar pulso
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  // Leer el tiempo del eco con timeout
  duracionUltrasonico = pulseIn(echoPin, HIGH, 25000); // Timeout ~4m
  // Calcular distancia en cm
  distanciaObstaculo = duracionUltrasonico * 0.034 / 2;

  // Limitar valores irreales
  if (distanciaObstaculo <= 0 || distanciaObstaculo > 400) {
    distanciaObstaculo = 400; // Asumir sin obstáculo si la lectura es inválida
  }
}
