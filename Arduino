// Pines de motor
const int motorIzqA = 5;
const int motorIzqB = 6;
const int motorDerA = 9;
const int motorDerB = 10;

// Pines ultrasónico
const int trigPin = 7;
const int echoPin = 8;

// Variables para medición de distancia
long duracion;
int distancia;
bool giroDerecha = true; // alterna dirección de giro

// Constantes configurables
const int DISTANCIA_MINIMA = 15;  // Distancia mínima en cm antes de girar
const int TIEMPO_GIRO = 500;      // Tiempo de giro en ms (reducido)
const int MUESTRAS_DISTANCIA = 3; // Número de muestras para promediar la distancia
const int TIEMPO_AVANCE_MIN = 500; // Tiempo mínimo de avance después de un giro

// Variables de control
unsigned long ultimoTiempoGiro = 0;
bool enModoEvitarObstaculo = false;

void setup() {
  // Configuración de pines de motor como salidas
  pinMode(motorIzqA, OUTPUT);
  pinMode(motorIzqB, OUTPUT);
  pinMode(motorDerA, OUTPUT);
  pinMode(motorDerB, OUTPUT);
  
  // Configuración de pines del sensor ultrasónico
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  
  // Iniciar comunicación serial para depuración
  Serial.begin(9600);
  
  // Pequeña pausa antes de comenzar
  delay(1000);
  Serial.println("Carro evita obstáculos iniciado");
  
  // Asegurar que el carro esté detenido al inicio
  detener();
  delay(500);
}

void loop() {
  // Medir la distancia al obstáculo
  medirDistancia();
  
  // Mostrar la distancia en el monitor serial
  Serial.print("Distancia: ");
  Serial.print(distancia);
  Serial.println(" cm");
  
  // Verificar si ha pasado suficiente tiempo desde el último giro
  bool tiempoSuficienteDespuesDeGiro = (millis() - ultimoTiempoGiro) > TIEMPO_AVANCE_MIN;
  
  // Lógica para evitar obstáculos
  if (distancia < DISTANCIA_MINIMA && tiempoSuficienteDespuesDeGiro) {
    // Si hay un obstáculo cercano y ha pasado suficiente tiempo desde el último giro
    Serial.println("¡Obstáculo detectado!");
    
    // Marcar que estamos en modo de evitar obstáculo
    enModoEvitarObstaculo = true;
    
    // Detener el carro
    detener();
    delay(300);
    
    // Retroceder un poco antes de girar
    Serial.println("Retrocediendo");
    retroceder();
    delay(400);
    detener();
    delay(200);
    
    // Girar en la dirección alternada
    if (giroDerecha) {
      Serial.println("Girando a la derecha");
      girarDerecha();
    } else {
      Serial.println("Girando a la izquierda");
      girarIzquierda();
    }
    
    delay(TIEMPO_GIRO); // Tiempo de giro
    
    // Detener después del giro
    detener();
    delay(200);
    
    // Alternar dirección para el siguiente obstáculo
    giroDerecha = !giroDerecha;
    
    // Registrar el tiempo del último giro
    ultimoTiempoGiro = millis();
    
    // Verificar si el camino está despejado después del giro
    medirDistancia();
    if (distancia < DISTANCIA_MINIMA) {
      // Si aún hay obstáculo, girar más
      Serial.println("Aún hay obstáculo, girando más");
      if (giroDerecha) {
        girarIzquierda(); // Girar en dirección opuesta
      } else {
        girarDerecha();
      }
      delay(TIEMPO_GIRO);
      detener();
      delay(200);
    }
    
    // Salir del modo de evitar obstáculo
    enModoEvitarObstaculo = false;
    
  } else {
    // Si no hay obstáculos o estamos en periodo de espera después de un giro, avanzar
    if (!enModoEvitarObstaculo) {
      avanzar();
    }
  }
  
  // Pequeña pausa para estabilizar lecturas
  delay(50);
}

// Función para avanzar
void avanzar() {
  digitalWrite(motorIzqA, HIGH);
  digitalWrite(motorIzqB, LOW);
  digitalWrite(motorDerA, HIGH);
  digitalWrite(motorDerB, LOW);
}

// Función para retroceder
void retroceder() {
  digitalWrite(motorIzqA, LOW);
  digitalWrite(motorIzqB, HIGH);
  digitalWrite(motorDerA, LOW);
  digitalWrite(motorDerB, HIGH);
}

// Función para girar a la derecha
void girarDerecha() {
  digitalWrite(motorIzqA, HIGH);
  digitalWrite(motorIzqB, LOW);
  digitalWrite(motorDerA, LOW);
  digitalWrite(motorDerB, HIGH);
}

// Función para girar a la izquierda
void girarIzquierda() {
  digitalWrite(motorIzqA, LOW);
  digitalWrite(motorIzqB, HIGH);
  digitalWrite(motorDerA, HIGH);
  digitalWrite(motorDerB, LOW);
}

// Función para detener el carro
void detener() {
  digitalWrite(motorIzqA, LOW);
  digitalWrite(motorIzqB, LOW);
  digitalWrite(motorDerA, LOW);
  digitalWrite(motorDerB, LOW);
}

// Función para medir la distancia con el sensor ultrasónico
void medirDistancia() {
  long suma = 0;
  int medicionesValidas = 0;
  
  // Tomar varias muestras y promediar para mayor precisión
  for (int i = 0; i < MUESTRAS_DISTANCIA; i++) {
    // Limpiar el trigger
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    
    // Enviar pulso de 10 microsegundos
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);
    
    // Leer el tiempo que tarda en volver el eco
    long lectura = pulseIn(echoPin, HIGH, 23200); // Timeout de ~4m
    
    if (lectura > 0) {
      suma += lectura;
      medicionesValidas++;
    }
    
    delay(10);
  }
  
  // Calcular el promedio (evitar división por cero)
  if (medicionesValidas > 0) {
    duracion = suma / medicionesValidas;
    // Convertir a distancia en cm (velocidad del sonido = 0.034 cm/us)
    distancia = duracion * 0.034 / 2;
  } else {
    // Si no hay mediciones válidas, asumir camino despejado
    distancia = 400;
  }
  
  // Limitar el rango de distancia
  if (distancia <= 0 || distancia > 400) {
    distancia = 400; // Valor máximo arbitrario
  }
}
