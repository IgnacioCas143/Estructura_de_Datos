
// Código combinado para Carro Lafvin: Evita Obstáculos y Sigue Línea Negra

// --- Pines de Motores ---
const int motorIzqA = 5;  // Motor Izquierdo A
const int motorIzqB = 6;  // Motor Izquierdo B
const int motorDerA = 10; // Motor Derecho A (Cambiado de 9)
const int motorDerB = 11; // Motor Derecho B (Cambiado de 10)

// --- Pines Sensor Ultrasónico ---
const int trigPin = 12; // Pin Trig (Cambiado de 7)
const int echoPin = 13; // Pin Echo (Cambiado de 8)

// --- Pines Sensores IR (Seguidor de Línea) ---
const int sensorIzquierdo = 7;  // Sensor IR Izquierdo (D7)
const int sensorCentral = 8;    // Sensor IR Central (D8)
const int sensorDerecho = 9;    // Sensor IR Derecho (D9)

// --- Constantes Configurables ---
// Obstáculo
const int DISTANCIA_MINIMA = 20;  // Distancia mínima en cm para evitar obstáculo
const int TIEMPO_GIRO_OBSTACULO = 500; // Tiempo de giro para evitar obstáculo (ms)
const int TIEMPO_RETROCESO = 300; // Tiempo de retroceso (ms)
// Línea
const int VELOCIDAD_NORMAL = 180;  // Velocidad normal seguidor (0-255)
const int VELOCIDAD_GIRO_LINEA = 150; // Velocidad giro seguidor (0-255)
const bool LINEA_NEGRA = true;     // true para línea negra, false para línea blanca
// Motores
const bool INVERTIR_MOTOR_IZQ = false; // Cambiar a true si el motor izquierdo gira al revés
const bool INVERTIR_MOTOR_DER = true;  // Puesto a true para intentar corregir el problema del giro

// --- Variables Globales ---
// Obstáculo
long duracionUltrasonico;
int distanciaObstaculo;
bool giroDerechaObstaculo = true; // Dirección de giro para evitar obstáculo
// Línea
int valorIzquierdoIR;
int valorCentralIR;
int valorDerechoIR;

void setup() {
  // Iniciar comunicación serial
  Serial.begin(9600);
  Serial.println("Iniciando Carro Lafvin Combinado...");

  // Configurar pines de motores como SALIDA
  pinMode(motorIzqA, OUTPUT);
  pinMode(motorIzqB, OUTPUT);
  pinMode(motorDerA, OUTPUT);
  pinMode(motorDerB, OUTPUT);

  // Configurar pines sensor ultrasónico
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // Configurar pines sensores IR como ENTRADA
  pinMode(sensorIzquierdo, INPUT);
  pinMode(sensorCentral, INPUT);
  pinMode(sensorDerecho, INPUT);

  // Detener motores al inicio
  detener();
  Serial.println("Motores detenidos.");
  delay(500);

  // --- Prueba de Motores ---
  Serial.println("Iniciando prueba de motores...");
  // Izquierdo Adelante
  Serial.print("Probando Izquierdo Adelante...");
  controlMotor(motorIzqA, motorIzqB, HIGH, LOW, INVERTIR_MOTOR_IZQ); // Izquierdo ON
  controlMotor(motorDerA, motorDerB, LOW, LOW, INVERTIR_MOTOR_DER);  // Derecho OFF
  delay(1000);
  detener();
  Serial.println(" OK");
  delay(500);
  // Derecho Adelante
  Serial.print("Probando Derecho Adelante...");
  controlMotor(motorIzqA, motorIzqB, LOW, LOW, INVERTIR_MOTOR_IZQ); // Izquierdo OFF
  controlMotor(motorDerA, motorDerB, HIGH, LOW, INVERTIR_MOTOR_DER); // Derecho ON
  delay(1000);
  detener();
  Serial.println(" OK");
  delay(500);
  Serial.println("Prueba de motores finalizada.");

  Serial.println("Sistema listo.");
}

void loop() {
  // 1. Medir distancia del obstáculo (Mayor Prioridad)
  medirDistancia();
  Serial.print("Distancia Obstaculo: ");
  Serial.print(distanciaObstaculo);
  Serial.println(" cm");

  // 2. Lógica de Evasión de Obstáculos
  if (distanciaObstaculo < DISTANCIA_MINIMA && distanciaObstaculo > 0) { // Ignorar lecturas 0
    Serial.println("¡Obstáculo Detectado!");
    detener();
    delay(200);
    // Retroceder
    Serial.println("Retrocediendo...");
    retroceder(VELOCIDAD_NORMAL);
    delay(TIEMPO_RETROCESO);
    detener();
    delay(200);
    // Girar para evitar
    if (giroDerechaObstaculo) {
      Serial.println("Girando a la Derecha (Obstáculo)");
      girarDerecha(VELOCIDAD_GIRO_LINEA); // Usar velocidad de giro de línea
    } else {
      Serial.println("Girando a la Izquierda (Obstáculo)");
      girarIzquierda(VELOCIDAD_GIRO_LINEA);
    }
    delay(TIEMPO_GIRO_OBSTACULO);
    detener();
    delay(200);
    // Alternar dirección de giro para la próxima vez
    giroDerechaObstaculo = !giroDerechaObstaculo;
  }
  // 3. Si no hay obstáculo, seguir la línea
  else {
    leerSensoresIR();
    mostrarValoresSensoresIR();

    if (LINEA_NEGRA) {
      seguirLineaNegra();
    } else {
      // Aquí iría la lógica para línea blanca si la necesitaras
      Serial.println("Modo línea blanca no implementado completamente");
      detener(); // Detener si no está configurado para línea blanca
    }
  }

  delay(50); // Pequeña pausa en el bucle
}

// --- Funciones de Control de Motores (con inversión) ---

// Función genérica para controlar un par de pines de motor con inversión
void controlMotor(int pinA, int pinB, int estadoA, int estadoB, bool invertir) {
  if (invertir) {
    // Invierte los estados si es necesario
    digitalWrite(pinA, estadoB);
    digitalWrite(pinB, estadoA);
  } else {
    digitalWrite(pinA, estadoA);
    digitalWrite(pinB, estadoB);
  }
}

void avanzar(int velocidad) { // velocidad no se usa con digitalWrite, pero se mantiene por consistencia
  controlMotor(motorIzqA, motorIzqB, HIGH, LOW, INVERTIR_MOTOR_IZQ);
  controlMotor(motorDerA, motorDerB, HIGH, LOW, INVERTIR_MOTOR_DER);
  // Serial.println("Avanzando"); // Descomentar si necesitas mucho detalle
}

void retroceder(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, LOW, HIGH, INVERTIR_MOTOR_IZQ);
  controlMotor(motorDerA, motorDerB, LOW, HIGH, INVERTIR_MOTOR_DER);
  // Serial.println("Retrocediendo");
}

void girarDerecha(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, HIGH, LOW, INVERTIR_MOTOR_IZQ); // Izquierda adelante
  controlMotor(motorDerA, motorDerB, LOW, HIGH, INVERTIR_MOTOR_DER); // Derecha atrás
  // Serial.println("Girando Derecha");
}

void girarIzquierda(int velocidad) {
  controlMotor(motorIzqA, motorIzqB, LOW, HIGH, INVERTIR_MOTOR_IZQ); // Izquierda atrás
  controlMotor(motorDerA, motorDerB, HIGH, LOW, INVERTIR_MOTOR_DER); // Derecha adelante
  // Serial.println("Girando Izquierda");
}

void detener() {
  controlMotor(motorIzqA, motorIzqB, LOW, LOW, INVERTIR_MOTOR_IZQ);
  controlMotor(motorDerA, motorDerB, LOW, LOW, INVERTIR_MOTOR_DER);
  // Serial.println("Detenido");
}

// --- Funciones del Sensor Ultrasónico ---
void medirDistancia() {
  // Limpiar el trigger
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  // Enviar pulso
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  // Leer el tiempo del eco con timeout
  duracionUltrasonico = pulseIn(echoPin, HIGH, 25000); // Timeout ~4m
  // Calcular distancia en cm
  distanciaObstaculo = duracionUltrasonico * 0.034 / 2;

  // Limitar valores irreales
  if (distanciaObstaculo <= 0 || distanciaObstaculo > 400) {
    distanciaObstaculo = 400; // Asumir sin obstáculo si la lectura es inválida
  }
}

// --- Funciones Sensores IR ---
void leerSensoresIR() {
  // Lectura simple, se puede mejorar con promedios si hay ruido
  valorIzquierdoIR = digitalRead(sensorIzquierdo);
  valorCentralIR = digitalRead(sensorCentral);
  valorDerechoIR = digitalRead(sensorDerecho);
}

void mostrarValoresSensoresIR() {
  Serial.print("Sensores IR (I,C,D): ");
  Serial.print(valorIzquierdoIR == LOW ? "N" : "B"); // N=Negro, B=Blanco
  Serial.print(", ");
  Serial.print(valorCentralIR == LOW ? "N" : "B");
  Serial.print(", ");
  Serial.println(valorDerechoIR == LOW ? "N" : "B");
}

// --- Lógica Seguidor de Línea ---
void seguirLineaNegra() {
  // Para línea negra: LOW = línea detectada, HIGH = fondo claro

  // Caso 1: Solo el central ve la línea -> Avanzar
  if (valorIzquierdoIR == HIGH && valorCentralIR == LOW && valorDerechoIR == HIGH) {
    Serial.println("Línea: Avanzar");
    avanzar(VELOCIDAD_NORMAL);
  }
  // Caso 2: Izquierdo ve la línea (o izquierdo y central) -> Girar Izquierda
  else if (valorIzquierdoIR == LOW && valorDerechoIR == HIGH) {
     Serial.println("Línea: Girar Izquierda");
     girarIzquierda(VELOCIDAD_GIRO_LINEA);
  }
  // Caso 3: Derecho ve la línea (o derecho y central) -> Girar Derecha
  else if (valorIzquierdoIR == HIGH && valorDerechoIR == LOW) {
     Serial.println("Línea: Girar Derecha");
     girarDerecha(VELOCIDAD_GIRO_LINEA);
  }
  // Caso 4: Ninguno ve la línea -> Detenerse o buscar (aquí detenemos)
  else if (valorIzquierdoIR == HIGH && valorCentralIR == HIGH && valorDerechoIR == HIGH) {
     Serial.println("Línea: Perdida - Detenido");
     detener(); // O implementar una rutina de búsqueda
  }
  // Caso 5: Todos ven la línea (cruce?) -> Avanzar o detenerse
  else if (valorIzquierdoIR == LOW && valorCentralIR == LOW && valorDerechoIR == LOW) {
     Serial.println("Línea: Cruce? - Avanzando");
     avanzar(VELOCIDAD_NORMAL); // Podrías detenerte o hacer otra acción aquí
  }
  // Otros casos (ej. solo laterales ven negro) - Podrían indicar error o fin de línea
  else {
      Serial.println("Línea: Estado inesperado - Detenido");
      detener();
  }
}
